**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[ã€è§†é¢‘è®²è§£ã€‘ | LeetCodeï¼š78.å­é›†](https://www.bilibili.com/video/BV1U84y1q7Ci)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘å†çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

# æ€è·¯

æ±‚å­é›†é—®é¢˜å’Œ[77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)å’Œ[131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)åˆä¸ä¸€æ ·äº†ã€‚

å¦‚æœæŠŠ å­é›†é—®é¢˜ã€ç»„åˆé—®é¢˜ã€åˆ†å‰²é—®é¢˜éƒ½æŠ½è±¡ä¸ºä¸€æ£µæ ‘çš„è¯ï¼Œ**é‚£ä¹ˆç»„åˆé—®é¢˜å’Œåˆ†å‰²é—®é¢˜éƒ½æ˜¯æ”¶é›†æ ‘çš„å¶å­èŠ‚ç‚¹ï¼Œè€Œå­é›†é—®é¢˜æ˜¯æ‰¾æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼**

å…¶å®å­é›†ä¹Ÿæ˜¯ä¸€ç§ç»„åˆé—®é¢˜ï¼Œå› ä¸ºå®ƒçš„é›†åˆæ˜¯æ— åºçš„ï¼Œå­é›†{1,2} å’Œ å­é›†{2,1}æ˜¯ä¸€æ ·çš„ã€‚

**é‚£ä¹ˆæ—¢ç„¶æ˜¯æ— åºï¼Œå–è¿‡çš„å…ƒç´ ä¸ä¼šé‡å¤å–ï¼Œå†™å›æº¯ç®—æ³•çš„æ—¶å€™ï¼Œforå°±è¦ä»startIndexå¼€å§‹ï¼Œè€Œä¸æ˜¯ä»0å¼€å§‹ï¼**

æœ‰åŒå­¦é—®äº†ï¼Œä»€ä¹ˆæ—¶å€™forå¯ä»¥ä»0å¼€å§‹å‘¢ï¼Ÿ

æ±‚æ’åˆ—é—®é¢˜çš„æ—¶å€™ï¼Œå°±è¦ä»0å¼€å§‹ï¼Œå› ä¸ºé›†åˆæ˜¯æœ‰åºçš„ï¼Œ{1, 2} å’Œ{2, 1}æ˜¯ä¸¤ä¸ªé›†åˆï¼Œæ’åˆ—é—®é¢˜æˆ‘ä»¬åç»­çš„æ–‡ç« å°±ä¼šè®²åˆ°çš„ã€‚

ä»¥ç¤ºä¾‹ä¸­nums = [1,2,3]ä¸ºä¾‹æŠŠæ±‚å­é›†æŠ½è±¡ä¸ºæ ‘å‹ç»“æ„ï¼Œå¦‚ä¸‹ï¼š

![image.png](https://pic.leetcode.cn/1674874362-hBHNCS-image.png)

ä»å›¾ä¸­çº¢çº¿éƒ¨åˆ†ï¼Œå¯ä»¥çœ‹å‡º**éå†è¿™ä¸ªæ ‘çš„æ—¶å€™ï¼ŒæŠŠæ‰€æœ‰èŠ‚ç‚¹éƒ½è®°å½•ä¸‹æ¥ï¼Œå°±æ˜¯è¦æ±‚çš„å­é›†é›†åˆ**ã€‚

## å›æº¯ä¸‰éƒ¨æ›²

* é€’å½’å‡½æ•°å‚æ•°

å…¨å±€å˜é‡æ•°ç»„pathä¸ºå­é›†æ”¶é›†å…ƒç´ ï¼ŒäºŒç»´æ•°ç»„resultå­˜æ”¾å­é›†ç»„åˆã€‚ï¼ˆä¹Ÿå¯ä»¥æ”¾åˆ°é€’å½’å‡½æ•°å‚æ•°é‡Œï¼‰

é€’å½’å‡½æ•°å‚æ•°åœ¨ä¸Šé¢è®²åˆ°äº†ï¼Œéœ€è¦startIndexã€‚

ä»£ç å¦‚ä¸‹ï¼š

* cpp

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking(vector<int>& nums, int startIndex) {
```

é€’å½’ç»ˆæ­¢æ¡ä»¶

ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼š

![image.png](https://pic.leetcode.cn/1674874362-hBHNCS-image.png)

å‰©ä½™é›†åˆä¸ºç©ºçš„æ—¶å€™ï¼Œå°±æ˜¯å¶å­èŠ‚ç‚¹ã€‚

é‚£ä¹ˆä»€ä¹ˆæ—¶å€™å‰©ä½™é›†åˆä¸ºç©ºå‘¢ï¼Ÿ

å°±æ˜¯startIndexå·²ç»å¤§äºæ•°ç»„çš„é•¿åº¦äº†ï¼Œå°±ç»ˆæ­¢äº†ï¼Œå› ä¸ºæ²¡æœ‰å…ƒç´ å¯å–äº†ï¼Œä»£ç å¦‚ä¸‹:

* cpp

```cpp
if (startIndex >= nums.size()) {
    return;
}
```

**å…¶å®å¯ä»¥ä¸éœ€è¦åŠ ç»ˆæ­¢æ¡ä»¶ï¼Œå› ä¸ºstartIndex >= nums.size()ï¼Œæœ¬å±‚forå¾ªç¯æœ¬æ¥ä¹Ÿç»“æŸäº†**ã€‚

* å•å±‚æœç´¢é€»è¾‘

**æ±‚å–å­é›†é—®é¢˜ï¼Œä¸éœ€è¦ä»»ä½•å‰ªæï¼å› ä¸ºå­é›†å°±æ˜¯è¦éå†æ•´æ£µæ ‘**ã€‚

é‚£ä¹ˆå•å±‚é€’å½’é€»è¾‘ä»£ç å¦‚ä¸‹ï¼š

* 

```
for (int i = startIndex; i < nums.size(); i++) {
    path.push_back(nums[i]);    // å­é›†æ”¶é›†å…ƒç´ 
    backtracking(nums, i + 1);  // æ³¨æ„ä»i+1å¼€å§‹ï¼Œå…ƒç´ ä¸é‡å¤å–
    path.pop_back();            // å›æº¯
}
```

## C++ä»£ç 

æ ¹æ®[å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)ç»™å‡ºçš„å›æº¯ç®—æ³•æ¨¡æ¿ï¼š

* 

```
void backtracking(å‚æ•°) {
    if (ç»ˆæ­¢æ¡ä»¶) {
        å­˜æ”¾ç»“æœ;
        return;
    }

    for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) {
        å¤„ç†èŠ‚ç‚¹;
        backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’
        å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ
    }
}
```

å¯ä»¥å†™å‡ºå¦‚ä¸‹å›æº¯ç®—æ³•C++ä»£ç ï¼š

* CPP

```CPP
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // æ”¶é›†å­é›†ï¼Œè¦æ”¾åœ¨ç»ˆæ­¢æ·»åŠ çš„ä¸Šé¢ï¼Œå¦åˆ™ä¼šæ¼æ‰è‡ªå·±
        if (startIndex >= nums.size()) { // ç»ˆæ­¢æ¡ä»¶å¯ä»¥ä¸åŠ 
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};

```

åœ¨æ³¨é‡Šä¸­ï¼Œå¯ä»¥å‘ç°å¯ä»¥ä¸å†™ç»ˆæ­¢æ¡ä»¶ï¼Œå› ä¸ºæœ¬æ¥æˆ‘ä»¬å°±è¦éå†æ•´æ£µæ ‘ã€‚

æœ‰çš„åŒå­¦å¯èƒ½æ‹…å¿ƒä¸å†™ç»ˆæ­¢æ¡ä»¶ä¼šä¸ä¼šæ— é™é€’å½’ï¼Ÿ

å¹¶ä¸ä¼šï¼Œå› ä¸ºæ¯æ¬¡é€’å½’çš„ä¸‹ä¸€å±‚å°±æ˜¯ä»i+1å¼€å§‹çš„ã€‚

# æ€»ç»“

ç›¸ä¿¡å¤§å®¶ç»è¿‡äº†
* ç»„åˆé—®é¢˜ï¼š
  * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
  * [å›æº¯ç®—æ³•ï¼šç»„åˆé—®é¢˜å†å‰ªå‰ªæ](https://programmercarl.com/0077.ç»„åˆä¼˜åŒ–.html)
  * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
  * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
  * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
  * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜ï¼š
  * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
  * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)

æ´—ç¤¼ä¹‹åï¼Œå‘ç°å­é›†é—®é¢˜è¿˜çœŸçš„æœ‰ç‚¹ç®€å•äº†ï¼Œå…¶å®è¿™å°±æ˜¯ä¸€é“æ ‡å‡†çš„æ¨¡æ¿é¢˜ã€‚

ä½†æ˜¯è¦æ¸…æ¥šå­é›†é—®é¢˜å’Œç»„åˆé—®é¢˜ã€åˆ†å‰²é—®é¢˜çš„çš„åŒºåˆ«ï¼Œ**å­é›†æ˜¯æ”¶é›†æ ‘å½¢ç»“æ„ä¸­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„ç»“æœ**ã€‚

**è€Œç»„åˆé—®é¢˜ã€åˆ†å‰²é—®é¢˜æ˜¯æ”¶é›†æ ‘å½¢ç»“æ„ä¸­å¶å­èŠ‚ç‚¹çš„ç»“æœ**ã€‚

# å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();// å­˜æ”¾ç¬¦åˆæ¡ä»¶ç»“æœçš„é›†åˆ
    LinkedList<Integer> path = new LinkedList<>();// ç”¨æ¥å­˜æ”¾ç¬¦åˆæ¡ä»¶ç»“æœ
    public List<List<Integer>> subsets(int[] nums) {
        subsetsHelper(nums, 0);
        return result;
    }

    private void subsetsHelper(int[] nums, int startIndex){
        result.add(new ArrayList<>(path));//ã€Œéå†è¿™ä¸ªæ ‘çš„æ—¶å€™ï¼ŒæŠŠæ‰€æœ‰èŠ‚ç‚¹éƒ½è®°å½•ä¸‹æ¥ï¼Œå°±æ˜¯è¦æ±‚çš„å­é›†é›†åˆã€ã€‚
        if (startIndex >= nums.length){ //ç»ˆæ­¢æ¡ä»¶å¯ä¸åŠ 
            return;
        }
        for (int i = startIndex; i < nums.length; i++){
            path.add(nums[i]);
            subsetsHelper(nums, i + 1);
            path.removeLast();
        }
    }
}
```

* []

```python
class Solution:
    def __init__(self):
        self.path: List[int] = []
        self.paths: List[List[int]] = []

    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.paths.clear()
        self.path.clear()
        self.backtracking(nums, 0)
        return self.paths

    def backtracking(self, nums: List[int], start_index: int) -> None:
        # æ”¶é›†å­é›†ï¼Œè¦å…ˆäºç»ˆæ­¢åˆ¤æ–­
        self.paths.append(self.path[:])
        # Base Case
        if start_index == len(nums):
            return

        # å•å±‚é€’å½’é€»è¾‘
        for i in range(start_index, len(nums)):
            self.path.append(nums[i])
            self.backtracking(nums, i+1)
            self.path.pop()     # å›æº¯
```

* []

```Go
var (
    path   []int
    res  [][]int
)
func subsets(nums []int) [][]int {
    res, path = make([][]int, 0), make([]int, 0, len(nums))
    dfs(nums, 0)
    return res
}
func dfs(nums []int, start int) {
    tmp := make([]int, len(path))
    copy(tmp, path)
    res = append(res, tmp)

    for i := start; i < len(nums); i++ {
        path = append(path, nums[i])
        dfs(nums, i+1)
        path = path[:len(path)-1]
    }
}
```

* []

```Javascript
var subsets = function(nums) {
    let result = []
    let path = []
    function backtracking(startIndex) {
        result.push([...path])
        for(let i = startIndex; i < nums.length; i++) {
            path.push(nums[i])
            backtracking(i + 1)
            path.pop()
        }
    }
    backtracking(0)
    return result
};
```

* []

```typescript
function subsets(nums: number[]): number[][] {
    const resArr: number[][] = [];
    backTracking(nums, 0, []);
    return resArr;
    function backTracking(nums: number[], startIndex: number, route: number[]): void {
        resArr.push([...route]);
        let length = nums.length;
        if (startIndex === length) return;
        for (let i = startIndex; i < length; i++) {
            route.push(nums[i]);
            backTracking(nums, i + 1, route);
            route.pop();
        }
    }
};
```

* []

```Rust
impl Solution {
    fn backtracking(result: &mut Vec<Vec<i32>>, path: &mut Vec<i32>, nums: &Vec<i32>, start_index: usize) {
        result.push(path.clone());
        let len = nums.len();
        // if start_index >= len { return; }
        for i in start_index..len {
            path.push(nums[i]);
            Self::backtracking(result, path, nums, i + 1);
            path.pop();
        }
    }

    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result: Vec<Vec<i32>> = Vec::new();
        let mut path: Vec<i32> = Vec::new();
        Self::backtracking(&mut result, &mut path, &nums, 0);
        result
    }
}
```

* []

```c
int* path;
int pathTop;
int** ans;
int ansTop;
//è®°å½•äºŒç»´æ•°ç»„ä¸­æ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦
int* length;
//å°†å½“å‰pathæ•°ç»„å¤åˆ¶åˆ°ansä¸­
void copy() {
    int* tempPath = (int*)malloc(sizeof(int) * pathTop);
    int i;
    for(i = 0; i < pathTop; i++) {
        tempPath[i] = path[i];
    }
    ans = (int**)realloc(ans, sizeof(int*) * (ansTop+1));
    length[ansTop] = pathTop;
    ans[ansTop++] = tempPath;
}

void backTracking(int* nums, int numsSize, int startIndex) {
    //æ”¶é›†å­é›†ï¼Œè¦æ”¾åœ¨ç»ˆæ­¢æ·»åŠ çš„ä¸Šé¢ï¼Œå¦åˆ™ä¼šæ¼æ‰è‡ªå·±
    copy();
    //è‹¥startIndexå¤§äºæ•°ç»„å¤§å°ï¼Œè¿”å›
    if(startIndex >= numsSize) {
        return;
    }
    int j;
    for(j = startIndex; j < numsSize; j++) {
        //å°†å½“å‰ä¸‹æ ‡æ•°å­—æ”¾å…¥pathä¸­
        path[pathTop++] = nums[j];
        backTracking(nums, numsSize, j+1);
        //å›æº¯
        pathTop--;
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    //åˆå§‹åŒ–è¾…åŠ©å˜é‡
    path = (int*)malloc(sizeof(int) * numsSize);
    ans = (int**)malloc(0);
    length = (int*)malloc(sizeof(int) * 1500);
    ansTop = pathTop = 0;
    //è¿›å…¥å›æº¯
    backTracking(nums, numsSize, 0);
    //è®¾ç½®äºŒç»´æ•°ç»„ä¸­å…ƒç´ ä¸ªæ•°
    *returnSize = ansTop;
    //è®¾ç½®äºŒç»´æ•°ç»„ä¸­æ¯ä¸ªä¸€ç»´æ•°ç»„çš„é•¿åº¦
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int i;
    for(i = 0; i < ansTop; i++) {
        (*returnColumnSizes)[i] = length[i];
    }
    return ans;
}
```

* []

```swift
func subsets(_ nums: [Int]) -> [[Int]] {
    var result = [[Int]]()
    var path = [Int]()
    func backtracking(startIndex: Int) {
        // ç›´æ¥æ”¶é›†ç»“æœ
        result.append(path)

        let end = nums.count
        guard startIndex < end else { return } // ç»ˆæ­¢æ¡ä»¶
        for i in startIndex ..< end {
            path.append(nums[i]) // å¤„ç†ï¼šæ”¶é›†å…ƒç´ 
            backtracking(startIndex: i + 1) // å…ƒç´ ä¸é‡å¤è®¿é—®
            path.removeLast() // å›æº¯
        }
    }
    backtracking(startIndex: 0)
    return result
}
```

* []

```scala
// æ€è·¯ä¸€: ä½¿ç”¨æœ¬é¢˜è§£æ€è·¯
object Solution {
  import scala.collection.mutable
  def subsets(nums: Array[Int]): List[List[Int]] = {
    var result = mutable.ListBuffer[List[Int]]()
    var path = mutable.ListBuffer[Int]()

    def backtracking(startIndex: Int): Unit = {
      result.append(path.toList) // å­˜æ”¾ç»“æœ
      if (startIndex >= nums.size) {
        return
      }
      for (i <- startIndex until nums.size) {
        path.append(nums(i)) // æ·»åŠ å…ƒç´ 
        backtracking(i + 1)
        path.remove(path.size - 1) // åˆ é™¤
      }
    }

    backtracking(0)
    result.toList
  }
}

// æ€è·¯äºŒ: å°†åŸé—®é¢˜è½¬æ¢ä¸ºäºŒå‰æ ‘ï¼Œé’ˆå¯¹æ¯ä¸€ä¸ªå…ƒç´ éƒ½æœ‰**é€‰æˆ–ä¸é€‰**ä¸¤ç§é€‰æ‹©ï¼Œç›´åˆ°éå†åˆ°æœ€åï¼Œæ‰€æœ‰çš„å¶å­èŠ‚ç‚¹å³ä¸ºæœ¬é¢˜çš„ç­”æ¡ˆï¼š
object Solution {
  import scala.collection.mutable
  def subsets(nums: Array[Int]): List[List[Int]] = {
    var result = mutable.ListBuffer[List[Int]]()

    def backtracking(path: mutable.ListBuffer[Int], startIndex: Int): Unit = {
      if (startIndex == nums.length) {
        result.append(path.toList)
        return
      }
      path.append(nums(startIndex))
      backtracking(path, startIndex + 1)  // é€‰æ‹©å…ƒç´ 
      path.remove(path.size - 1)
      backtracking(path, startIndex + 1)  // ä¸é€‰æ‹©å…ƒç´ 
    }

    backtracking(mutable.ListBuffer[Int](), 0)
    result.toList
  }
}
```

# å›æº¯ç®—æ³•åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ å›æº¯ç®—æ³•çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚

* [å…³äºå›æº¯ç®—æ³•ï¼Œä½ è¯¥äº†è§£è¿™äº›ï¼](https://programmercarl.com/å›æº¯ç®—æ³•ç†è®ºåŸºç¡€.html)
* ç»„åˆé—®é¢˜
  * [77.ç»„åˆ](https://programmercarl.com/0077.ç»„åˆ.html)
  * [216.ç»„åˆæ€»å’ŒIII](https://programmercarl.com/0216.ç»„åˆæ€»å’ŒIII.html)
  * [17.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](https://programmercarl.com/0017.ç”µè¯å·ç çš„å­—æ¯ç»„åˆ.html)
  * [39.ç»„åˆæ€»å’Œ](https://programmercarl.com/0039.ç»„åˆæ€»å’Œ.html)
  * [40.ç»„åˆæ€»å’ŒII](https://programmercarl.com/0040.ç»„åˆæ€»å’ŒII.html)
* åˆ†å‰²é—®é¢˜
  * [131.åˆ†å‰²å›æ–‡ä¸²](https://programmercarl.com/0131.åˆ†å‰²å›æ–‡ä¸².html)
  * [93.å¤åŸIPåœ°å€](https://programmercarl.com/0093.å¤åŸIPåœ°å€.html)
* å­é›†é—®é¢˜
  * [78.å­é›†](https://programmercarl.com/0078.å­é›†.html)
  * [90.å­é›†II](https://programmercarl.com/0090.å­é›†II.html)
* æ’åˆ—é—®é¢˜
  * [46.å…¨æ’åˆ—](https://programmercarl.com/0046.å…¨æ’åˆ—.html)
  * [47.å…¨æ’åˆ—II](https://programmercarl.com/0047.å…¨æ’åˆ—II.html)
* æ£‹ç›˜é—®é¢˜
  * [51.Nçš‡å](https://programmercarl.com/0051.Nçš‡å.html)
  * [37.è§£æ•°ç‹¬](https://programmercarl.com/0037.è§£æ•°ç‹¬.html)
* å…¶ä»–
  * [491.é€’å¢å­åºåˆ—](https://programmercarl.com/0491.é€’å¢å­åºåˆ—.html)
  * [332.é‡æ–°å®‰æ’è¡Œç¨‹](https://programmercarl.com/0332.é‡æ–°å®‰æ’è¡Œç¨‹.html)
* [å›æº¯ç®—æ³•æ€»ç»“ç¯‡](https://programmercarl.com/å›æº¯æ€»ç»“.html)

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**

